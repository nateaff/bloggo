---
title: Lego Topic Models
author: Nathanael Aff
date: '2017-08-21'
slug: lego-topic-models-rmd
categories: ['Data Science', 'R', 'NLP']
tags: ['Topic Models', 'EDA']
draft: yes
---


```{r global_options, echo = FALSE}
knitr::opts_chunk$set(
       knitr::opts_chunk$set(cache=TRUE),
       fig.align = 'center', 
       echo=FALSE, 
       warning=FALSE, 
       message=FALSE,  
       fig.width = 6.5, 
       fig.height = 6.5,
       dev = 'png', 
       eval = FALSE)
```

Introduction: 

We'll use topic models to explore the Lego dataset. 

The lego sets are grouped by theme and some themes have parent themes. Do the themes follow a color scheme and can we recover the theme from the color pieces. To put this another way, if we cluster the sets by color would we find that they cluster in a way that matches their themes? 

One way to approach the problem is to treat colors as text. There might be another approach but this also give me an excuse to try out so


### 

* Look at color tf-idf 
* Use perplexity to choose a number for our topic models
*


### The themes

A number of themes had no parent. Some of these top-level parent themes but others were neither parents nor had a 'parent_id'. I removed these themes with a single set so that the clustering wouldn't be thrown off by too many unique themes. The `parent_set` is all those themes that are parent themes or have parent themes.

```{r themes, echo = FALSE, eval = TRUE}

library(ggplot2)
library(dplyr)
# Hide re-load
# import::from(dplyr, "%>%")
setwd("~/devel/R-proj/lego/data")
filenames <- dir() %>% sub(".csv", "", .)

options(warn = -1)
pg = RPostgreSQL::PostgreSQL()
con = DBI::dbConnect(pg, 
                user = "postgres", 
                password = keyringr::decrypt_gk_pw("db lego user postgres"), 
                host = "localhost", 
                port = 5432
                )

# Counts by theme
counts <- tbl(con, "themes") %>% 
          group_by(parent_id) %>% 
          count %>% 
          collect
sum(counts$n)

unique(counts$parent_id)

# Remove NA parents
parents <- counts %>% filter(!is.na(parent_id)) 
parent_set <- parents$parent_id

```
There are () unique themes including some subthemes. My guess is that while some themes will have a unique color signature, there will be 


```{r set-query, echo = FALSE, eval = TRUE}

# Get tables
themes <- tbl(con, "themes")
inventory_sets <- tbl(con, "inventory_sets")
inventories <- tbl(con, "inventories") 
inventory_parts <- tbl(con, "inventory_parts") 
colors <- tbl(con, "colors")
sets <- tbl(con, "sets") 

set_colors <- 
  themes %>% 
  # Filter out no-parent sets
  filter(parent_id %in% parent_set|| id %in% parent_set) %>% 
  mutate(theme = name, theme_id = id) %>% 
  select(theme, theme_id) %>%
  right_join(sets, by = 'theme_id') %>%
  select(set_num, name, year, theme_id, theme) %>% 
  right_join(inventories, by = 'set_num', copy = TRUE) %>% 
  right_join(inventory_parts, by = c('id' = 'inventory_id')) %>%
  filter(!is.na(year)) %>%
  left_join(colors, by = c('color_id' = 'id')) %>%
  mutate(name = name.x) %>% 
  select(set_num, name, theme, theme_id, rgb, year, is_trans, quantity) %>%
  collect 
        
DBI::dbDisconnect(con)

# Perform in-memory filtering and mutation
set_colors <- 
  set_colors %>% 
  mutate(name = stringr::str_sub(name, 1, 20)) %>%
  # Add alpha, transparent = 0.5 = '80', opaque = 'FF
  mutate(rgba = ifelse(is_trans == 't', 
                  paste0("#", rgb, '80'), 
                  paste0("#", rgb, 'FF'))) %>% 
  select(set_num, name, theme, theme_id,year, rgba, quantity) %>% 
  sample_n(100000) 

head(set_colors)

# Expand by quantity column and remove quantity
set_colors <- 
  set_colors[rep(seq(nrow(set_colors)), set_colors$quantity),] %>% 
  select(-quantity)
```

### TF-IDF 

Definition of tf-idf 

We expect the top tf-idf entries to be sets with a much higher than average number of some rare color while low color and set combinations with low tf-idf  ... common color. 

```{r tf-idf, echo = FALSE, eval = TRUE}
# Compute tf-idf
# idf(term) = ln( n-docs/n-docs with term)
# Compare Tidytext : http://tidytextmining.com/tfidf.html
set_words <- set_colors %>% 
             count(name, set_num, rgba, sort = TRUE) %>%
             ungroup()

total_words <- set_words %>%
              group_by(set_num) %>%
              summarize(total = sum(n))

set_words <- left_join(set_words, total_words, by = 'set_num')

# Term Frequency

# Create palette
pal <- unique(set_colors$rgba)
names(pal) <- unique(pal) 

set_words <- set_words %>%
  tidytext::bind_tf_idf(rgba, set_num, n)

top <- set_words %>%   
       arrange(desc(tf_idf)) %>%
       mutate(rgba = factor(rgba, levels = unique(rgba))) %>%
       head(20)

tail <- set_words %>%   
       arrange(desc(tf_idf)) %>%
       mutate(rgba = factor(rgba, levels = unique(rgba))) %>%
       tail(20)

# Highest td-idf
top %>%
ggplot() +
  geom_bar(aes(x = rgba, y = tf_idf, fill = rgba), 
    stat = 'identity', 
    show.legend = FALSE) +
  scale_fill_manual(values = pal) + 
  labs(x = NULL, y = "tf-idf") +
  coord_flip() + 
  theme_minimal() +
  # theme(axis.text.y=element_blank())+
  facet_wrap(~name, nrow = 3)

# Lowest td-idf
tail  %>%
ggplot() +
  geom_bar(aes(x = rgba, y = tf_idf, fill = rgba), 
    stat = 'identity', 
    show.legend = FALSE) +
  scale_fill_manual(values = pal) + 
  labs(x = NULL, y = "tf-idf") +
  coord_flip() + 
  theme_minimal()+
  theme( axis.text.x=element_blank()) +
  facet_wrap(~name, nrow = 5)
 
```


### LDA 

Definition 

```{r lda1, eval = FALSE}
library(topicmodels)
n_topics <- c(5, 10, 25, 35, 50, 65, 80, 100)

# Fit models - This is compute intensive and takes a few minutes
set_lda_compare <- n_topics %>%
purrr::map(LDA, x = set_dtm, control = list(seed = 1109))

``` 

```{r load-lda, eval = TRUE, echo = FALSE}
n_topics <- c(5, 10, 25, 35, 50, 65, 80, 100)
# saveRDS(set_lda_compare, "~/devel/R-proj/lego/cache/set_lda_compare.RDS")
set_lda_compare <- readRDS("~/devel/R-proj/lego/cache/set_lda_compare.RDS")
library(topicmodels)
library(dplyr)

data_frame(k = n_topics,
           perplex = purrr::map_dbl(set_lda_compare, perplexity)) %>%
  ggplot(aes(k, perplex)) +
  geom_point() +
  geom_line() +
  labs(title = "Evaluating LDA topic models",
       subtitle = "Optimal number of topics (smaller is better)",
       x = "Number of topics",
       y = "Perplexity") + 
  theme_minimal()

# Take two best models to compare
ind35 <- which(n_topics == 35)
ind50 <- which(n_topics == 50)

set_lda35 <- set_lda_compare[[ind35]]
set_lda50 <- set_lda_compare[[ind50]]
```

### Topic Modeling 
[Tidytext](http://tidytextmining.com/topicmodeling.html)


Note that tidy returns the Beta or Gamma matrix along with the term and topic in a tidy (long) data frame. Here a term is a color.

```{r top-terms, echo = FALSE, eval = TRUE}
# Plot the top ''
set_topics <- tidytext::tidy(set_lda35, matrix = 'beta')

top_terms <- set_topics %>%
  group_by(topic) %>%
  top_n(3, beta) %>%
  ungroup() %>%
  arrange(topic, -beta)

top_terms %>%
  mutate(term = reorder(term, beta)) %>%
  ggplot(aes(term, beta, fill = term)) +
  labs(x ='') +
  geom_col(show.legend = FALSE) +
  facet_wrap(~ topic, scales = "free_y", nrow =10) +
  scale_fill_manual(values = pal) + 
  coord_flip() + 
  theme_minimal() +
  theme(axis.text.y=element_blank())

set_topics <- broom::tidy(set_lda50, matrix = 'beta')

top_terms <- set_topics %>%
  group_by(topic) %>%
  top_n(3, beta) %>%
  ungroup() %>%
  arrange(topic, -beta)

top_terms %>%
  mutate(term = reorder(term, beta)) %>%
  ggplot(aes(term, beta, fill = term)) +
  labs(x ='') +
  geom_col(show.legend = FALSE) +
  facet_wrap(~ topic, scales = "free_y", nrow =10) +
  scale_fill_manual(values = pal) + 
  coord_flip() + 
  theme_minimal() +
  theme(axis.text.y=element_blank())

```

The Gamma is the posterior distirbution over topics. The Beta distribution is the generative model or distribution from which a given topic is drawn. (Clarify)


```{r top-docs, echo = FALSE, eval = TRUE}  
# Tidy Gamma matrix
set_docs <- tidytext::tidy(set_lda35, matrix = "gamma")

# Find the "purest" topics and see what sets they are 
# associated with 
top_docs <- set_docs %>% arrange(desc(gamma)) %>% head(50)

topic <- set_docs %>%
         filter(topic == 3) %>% 
         arrange(desc(gamma)) %>%
         head(20) 
topic$document


topic <- set_docs %>%
         filter(topic == 21) %>% 
         arrange(desc(gamma)) %>%
         head(20) 
topic$document

```
Do they match the sets? 

```{r set-inclusion}


```












